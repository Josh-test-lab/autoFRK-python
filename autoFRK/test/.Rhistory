#### end of independent multi-realization simulation example
one.usr
attr(one.usr)
attr(one.usr, "miss")
attr(one.usr, "missing")
?LKrig.basis
logDeterminant
# R
mat_pd <- matrix(c(2, 0.5,
0.5, 1), nrow=2, byrow=TRUE)
logdet_pd <- determinant(mat_pd, logarithm=TRUE)$modulus[1]
logdet_pd
# R
mat_npd <- matrix(c(0, 1,
1, 0), nrow=2, byrow=TRUE)
logdet_npd <- determinant(mat_npd, logarithm=TRUE)$modulus[1]
logdet_npd
# R
mat_pd <- matrix(c(4, 1, 1,
1, 3, 0,
1, 0, 2), nrow=3, byrow=TRUE)
logdet_pd <- determinant(mat_pd, logarithm=TRUE)$modulus[1]
logdet_pd
# R
mat_psd <- matrix(c(2, -2, 0,
-2, 2, 0,
0, 0, 0), nrow=3, byrow=TRUE)
logdet_psd <- determinant(mat_psd, logarithm=TRUE)$modulus[1]
logdet_psd
# logDeterminant
# 正定矩陣
mat_pd <- matrix(c(4, 1, 1,
1, 3, 0,
1, 0, 2), nrow=3, byrow=TRUE)
logdet_pd <- logDeterminant(mat_pd)
logdet_pd
# 半正定矩陣
mat_psd <- matrix(c(2, -2, 0,
-2, 2, 0,
0, 0, 0), nrow=3, byrow=TRUE)
logdet_psd <- logDeterminant(mat_psd)
logdet_psd
# 非正定矩陣
mat_npd <- matrix(c(0, 1, 2,
1, 0, 1,
2, 1, 0), nrow=3, byrow=TRUE)
logdet_npd <- logDeterminant(mat_npd)
logdet_npd
# 非正定矩陣範例
mat_npd2 <- matrix(c(0, 2, 1,
2, 0, 1,
1, 1, 0), nrow=3, byrow=TRUE)
# 使用 logDeterminant
logdet_npd2 <- logDeterminant(mat_npd2)
logdet_npd2
# cMLEsp
# R 測試資料
set.seed(123)
n <- 5
K <- 3
Tn <- 4
Fk <- matrix(rnorm(n*K), nrow=n, ncol=K)
data <- matrix(rnorm(n*Tn), nrow=n, ncol=Tn)
Depsilon <- diag(runif(n, 0.5, 2))
# 呼叫
result <- cMLEsp(Fk, data, Depsilon, wSave = TRUE)
result
# cMLEsp
# R 測試資料
Fk <- matrix(c(1,2,3,
4,5,6,
7,8,9,
10,11,12,
13,14,15), nrow=5, byrow=TRUE)
data <- matrix(c(1,2,3,4,
5,6,7,8,
9,10,11,12,
13,14,15,16,
17,18,19,20), nrow=5, byrow=TRUE)
Depsilon <- diag(c(1,2,3,4,5))
# 呼叫
result <- cMLEsp(Fk, data, Depsilon, wSave = TRUE)
# cMLEsp
# R 測試資料
Fk <- matrix(c(1,0,0,
0,1,0,
0,0,1,
1,1,0,
0,1,1), nrow=5, byrow=TRUE)
data <- matrix(c(1,2,3,4,
2,3,4,5,
3,4,5,6,
4,5,6,7,
5,6,7,8), nrow=5, byrow=TRUE)
Depsilon <- diag(c(1,1,1,1,1))
# 呼叫
result <- cMLEsp(Fk, data, Depsilon, wSave = TRUE)
result
if ("numeric" %in% class(data)){
data <- as.matrix(data)}
De <- toSparseMatrix(Depsilon)
iD <- solve(De)
ldetD <- logDeterminant(De)
iDFk <- iD %*% Fk
num_columns <- NCOL(data)
De
De
iD
ldetD
iDFk
num_columns
projection <- computeProjectionMatrix(Fk, iDFk, data)
projection
inverse_square_root_matrix <-
projection$inverse_square_root_matrix
matrix_JSJ <- projection$matrix_JSJ
trS <- sum(rowSums(as.matrix(iD %*% data) * data)) / num_columns
out <- cMLE(
Fk,
num_columns,
trS,
inverse_square_root_matrix,
matrix_JSJ,
s = 0,
ldet = ldetD,
wSave
)
trS
out
# 固定資料
Fk <- matrix(c(1,0,0,
0,1,0,
0,0,1,
1,1,0,
0,1,1), nrow=5, byrow=TRUE)
num_columns <- 4
sample_covariance_trace <- 10
inverse_square_root_matrix <- diag(1, 5)
matrix_JSJ <- diag(1, 3)
s <- 0
ldet <- 0
wSave <- TRUE
# 呼叫 cMLE
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
# 固定資料
Fk <- matrix(c(1,0,0,
0,1,0,
0,0,1,
1,1,0,
0,1,1), nrow=5, byrow=TRUE)
num_columns <- 4
sample_covariance_trace <- 10
inverse_square_root_matrix <- diag(1, 5)
matrix_JSJ <- diag(1, 3)
s <- 0
ldet <- 0
wSave <- TRUE
# 呼叫 cMLE
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
# 固定資料
Fk <- matrix(c(1,0,0,
0,1,0,
0,0,1,
1,1,0,
0,1,1), nrow=5, byrow=TRUE)
num_columns <- 4
sample_covariance_trace <- 10
inverse_square_root_matrix <- diag(1, 5)
matrix_JSJ <- diag(1, 3)
s <- 0
ldet <- 0
wSave <- TRUE
# 呼叫 cMLE
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
# 固定測試資料
Fk <- matrix(c(1,0,
0,1,
1,1), nrow=3, byrow=TRUE)  # 3x2
num_columns <- 2
sample_covariance_trace <- 5
inverse_square_root_matrix <- diag(1, 3)  # 與 nrow(Fk) = 3 對應
matrix_JSJ <- diag(1, 2)  # 與 ncol(Fk) = 2 對應
s <- 0
ldet <- 0
wSave <- TRUE
# 呼叫 cMLE
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
# 固定測試資料 (第2組)
Fk <- matrix(c(2, 1,
4, 3,
6, 5,
8, 7,
10, 9), nrow=5, byrow=TRUE)  # 5x2
num_columns <- 4
sample_covariance_trace <- 20
inverse_square_root_matrix <- diag(c(1, 0.9, 0.8, 0.7, 0.6))  # 5x5
matrix_JSJ <- matrix(c(2, 0.3,
0.3, 1.5), nrow=2, byrow=TRUE)  # 2x2
s <- 0.5
ldet <- 0.2
wSave <- TRUE
# 呼叫 cMLE
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
Fk <- matrix(c(1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 1), nrow = 4, byrow = TRUE)  # n=4, K=3
num_columns <- 3
sample_covariance_trace <- 10
inverse_square_root_matrix <- diag(1, 3)  # K x K
matrix_JSJ <- matrix(c(2, 0.1, 0.2,
0.1, 1.5, 0.05,
0.2, 0.05, 1.0),
nrow = 3, byrow = TRUE)
s <- 0.5
ldet <- 0.1
wSave <- TRUE
# ---- 呼叫 cMLE ----
result <- cMLE(Fk,
num_columns,
sample_covariance_trace,
inverse_square_root_matrix,
matrix_JSJ,
s = s,
ldet = ldet,
wSave = wSave)
print(result)
# cMLElk
# 固定測試資料 ----
Fk <- matrix(c(1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 1), nrow = 4, byrow = TRUE)  # 4x3
data <- matrix(c(2, 3,
4, 5,
6, 7,
8, 9), nrow = 4, byrow = TRUE)  # 4x2
Depsilon <- diag(c(0.1, 0.1, 0.1, 0.1))  # 4x4
DfromLK <- list(
lambda = 0.5,
pick = 1:4,
wX = matrix(c(1, 0.5,
0.3, 1.0,
0.8, 0.2,
0.4, 0.6), nrow = 4, byrow = TRUE),  # 4x2
weights = c(1.0, 0.8, 1.2, 1.0),
Q = matrix(c(1, 0.2,
0.2, 1), nrow = 2, byrow = TRUE)
)
# 呼叫函數 ----
result <- cMLElk(
Fk = Fk,
data = data,
Depsilon = Depsilon,
wSave = TRUE,
DfromLK = DfromLK
)
print(result)
wSave = TRUE
vfixed = NULL
Fk <- matrix(c(1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 1), nrow = 4, byrow = TRUE)  # 4x3
data <- matrix(c(2, 3,
4, 5,
6, 7,
8, 9), nrow = 4, byrow = TRUE)  # 4x2
Depsilon <- diag(c(0.1, 0.1, 0.1, 0.1))  # 4x4
DfromLK <- list(
lambda = 0.5,
pick = 1:4,
wX = matrix(c(1, 0.5,
0.3, 1.0,
0.8, 0.2,
0.4, 0.6), nrow = 4, byrow = TRUE),  # 4x2
weights = c(1.0, 0.8, 1.2, 1.0),
Q = matrix(c(1, 0.2,
0.2, 1), nrow = 2, byrow = TRUE)
)
num_columns <- NCOL(data)
lambda <- DfromLK$lambda
pick <- DfromLK$pick
wX <- DfromLK$wX
weight <- DfromLK$weights
num_columns
lambda
pick
wX
weight
(length(pick)
)
dim(wX)[1]
if (length(pick) < dim(wX)[1]) {
wX <- wX[pick, ]
weight <- weight[pick]
}
G <- t(wX) %*% wX + lambda * DfromLK$Q
wwX <- diag.spam(sqrt(weight)) %*% wX
wXiG <- (wwX) %*% solve(G)
iDFk <- weight * Fk - wXiG %*% (t(wwX) %*% as.matrix(Fk))
G
wwX
wXiG
iDFk
weight
Fk
wXiG
t(wwX)
Fk
(t(wwX) %*% as.matrix(Fk))
wXiG %*% (t(wwX) %*% as.matrix(Fk))
weight * Fk
projection <- computeProjectionMatrix(Fk, iDFk, data)
inverse_square_root_matrix <- projection$inverse_square_root_matrix
matrix_JSJ <- projection$matrix_JSJ
iDZ <- weight * data - wXiG %*% (t(wwX) %*% as.matrix(data))
trS <- sum(rowSums(as.matrix(iDZ) * data)) / num_columns
ldetD <- -nrow(DfromLK$Q) * log(lambda) +
logDeterminant(G) -
logDeterminant(DfromLK$Q) -
sum(log(weight))
projection
inverse_square_root_matrix
matrix_JSJ
iDZ
trS
ldetD
out <- cMLE(
Fk,
num_columns,
trS,
inverse_square_root_matrix,
matrix_JSJ,
s = 0,
ldet = as.vector(ldetD),
wSave = TRUE,
onlylogLike = FALSE,
vfixed = vfixed
)
out
L <- out$L
out$s <- out$v
out <- out[-which(names(out) == "v")]
out <- out[-which(names(out) == "L")]
L
out
!wSave
iDL <- weight * L - wXiG %*% (t(wwX) %*% L)
itmp <- solve(diag(1, NCOL(L)) + t(L) %*% iDL / out$s)
iiLiD <- itmp %*% t(iDL / out$s)
MFiS11 <- out$M %*% t(iDFk) / out$s - ((out$M %*% t(iDFk / out$s)) %*% L) %*% iiLiD
out$w <- MFiS11 %*% data
out$V <- MFiS11 %*% (Fk %*% out$M)
wlk <- t(wXiG) %*% data - t(wXiG) %*% L %*% (iiLiD %*% data)
attr(out, "pinfo") <- list(wlk = wlk, pick = pick)
iDL
itmp
iiLiD
MFiS11
out
wlk
# 固定測試資料 ------------------------------------------------------
set.seed(123)
data <- matrix(c(
1.2, 1.5, 1.7, 1.6,
2.1, 2.3, 2.5, 2.4,
0.9, 1.1, 1.3, 1.2
), nrow = 3, byrow = TRUE)
Fk <- matrix(c(
1, 0.5,
1, 1.0,
1, 1.5
), nrow = 3, byrow = TRUE)
D <- diag(c(0.2, 0.25, 0.3))
# 假設 indeMLE 已經在 R 環境中定義
# （或是載入你自己的 indeMLE.R 檔）
# 呼叫 indeMLE
result <- indeMLE(
data = data,
Fk = Fk,
D = D,
wSave = TRUE,
verbose = FALSE
)
print(result)
# indeMLE
# 固定測試資料 ------------------------------------------------------
set.seed(123)
data <- matrix(c(
1.2, 1.5, 1.7, 1.6,
2.1, 2.3, 2.5, 2.4,
0.9, 1.1, 1.3, 1.2
), nrow = 3, byrow = TRUE)
Fk <- matrix(c(
1, 0.5,
1, 1.0,
1, 1.5
), nrow = 3, byrow = TRUE)
D <- diag(c(0.2, 0.25, 0.3))
# 假設 indeMLE 已經在 R 環境中定義
# （或是載入你自己的 indeMLE.R 檔）
# 呼叫 indeMLE
result <- indeMLE(
data = data,
Fk = Fk,
D = D,
wSave = TRUE,
verbose = FALSE
)
print(result)
set.seed(123)
data <- matrix(c(
1.2, 1.5, 1.7, 1.6,
2.1, 2.3, 2.5, 2.4,
0.9, 1.1, 1.3, 1.2
), nrow = 3, byrow = TRUE)
Fk <- matrix(c(
1, 0.5,
1, 1.0,
1, 1.5
), nrow = 3, byrow = TRUE)
D <- diag(c(0.2, 0.25, 0.3))
# 假設 indeMLE 已經在 R 環境中定義
# （或是載入你自己的 indeMLE.R 檔）
wSave = TRUE,
wSave = TRUE
verbose = FALSE
withNA <- sum(is.na(data)) > 0
if (is(data, "vector")) {
data <- as.matrix(data)
}
withNA
TT <- NCOL(data)
empty <- apply(!is.na(data), 2, sum) == 0
notempty <- which(!empty)
if (sum(empty) > 0) {
data <- as.matrix(data[, notempty])
}
TT
empty
notempty
del <- which(rowSums(as.matrix(!is.na(data))) == 0)
pick <- 1:NROW(data)
del
pick
if (!isDiagonal(D)) {
D0 <- toSparseMatrix(D)
} else {
D0 <- diag.spam(diag(D), NROW(data))
}
D0
# indeMLE
# 固定測試資料 ------------------------------------------------------
set.seed(123)
data <- matrix(c(
1.2, 1.5, 1.7, 1.6,
2.1, 2.3, 2.5, 2.4,
0.9, 1.1, 1.3, 1.2
), nrow = 3, byrow = TRUE)
Fk <- matrix(c(
1, 0.5,
1, 1.0,
1, 1.5
), nrow = 3, byrow = TRUE)
D <- diag(c(0.2, 0.25, 0.3))
# 假設 indeMLE 已經在 R 環境中定義
# （或是載入你自己的 indeMLE.R 檔）
# 呼叫 indeMLE
result <- indeMLE(
data = data,
Fk = Fk,
D = D,
wSave = TRUE,
verbose = FALSE
)
print(result)
